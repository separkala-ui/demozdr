<?php

declare(strict_types=1);

namespace App\Concerns\Datatable;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Str;
use Illuminate\Support\Facades\Schema;
use Illuminate\Support\Facades\DB;
use ReflectionClass;
use Spatie\QueryBuilder\QueryBuilder;

trait HasDatatableGenerator
{
    protected array $excludedColumns = [
        'password',
        'remember_token',
        'email_verified_at',
        'two_factor_secret',
        'two_factor_recovery_codes',
        'two_factor_confirmed_at',
        'current_team_id',
    ];

    protected array $relationships = [];

    protected int $maxColumns = 8;
    protected bool $enableActionColumn = true;

    protected array $searchableColumns = [];

    protected ?Model $modelInstance = null;

    private function getModelHeaders(): array
    {
        $modelClass = $this->getModelClass();

        if (empty($modelClass)) {
            throw new \Exception('Model class is required for auto-generation');
        }

        $this->modelInstance = new $modelClass();
        $headers = [];
        $searchableColumns = [];

        // Get database columns.
        $tableColumns = $this->getTableColumns();

        // Get fillable or guarded columns.
        $allowedColumns = $this->getAllowedColumns();

        // Generate basic column headers.
        foreach ($tableColumns as $column) {
            if (count($headers) >= $this->maxColumns) {
                break;
            }

            if ($this->shouldIncludeColumn($column, $allowedColumns)) {
                $headerData = $this->generateHeaderForColumn($column);
                $headers[] = $headerData;

                if ($headerData['searchable']) {
                    $searchableColumns[] = $column;
                }
            }
        }

        // Add relationship columns if specified.
        $relationshipHeaders = $this->generateRelationshipHeaders();
        $headers = array_merge($headers, $relationshipHeaders);

        // Auto-add actions column if the trait is used.
        if ($this->enableActionColumn) {
            $headers[] = $this->getActionsColumnHeader();
        }

        $this->searchableColumns = $searchableColumns;
        return $headers;
    }

    protected function getHeaders(): array
    {
        return $this->getModelHeaders();
    }

    protected function generateHeaderForColumn(string $column): array
    {
        $header = [
            'id' => $column,
            'title' => $this->formatColumnTitle($column),
            'sortBy' => $column,
            'searchable' => $this->isColumnSearchable($column),
            'sortable' => $this->isColumnSortable($column),
        ];

        // Add custom rendering for special columns.
        if ($this->needsCustomRenderer($column)) {
            $header['renderer'] = $this->getColumnRenderer($column);
        }

        return $header;
    }

    protected function generateRelationshipHeaders(): array
    {
        $headers = [];

        foreach ($this->relationships as $relationship) {
            if (count($headers) + count($this->autoGeneratedHeaders) >= $this->maxColumns) {
                break;
            }

            if ($this->modelHasRelationship($relationship)) {
                $headers[] = [
                    'id' => $relationship,
                    'title' => $this->formatColumnTitle($relationship),
                    'sortBy' => $this->getRelationshipSortColumn($relationship),
                    'searchable' => false, // Relationships are typically not directly searchable.
                    'sortable' => true,
                    'renderer' => "render{$this->studlyCase($relationship)}Column",
                ];
            }
        }

        return $headers;
    }

    /**
     * Get table columns from database
     */
    protected function getTableColumns(): array
    {
        if (! $this->modelInstance) {
            return [];
        }

        $table = $this->modelInstance->getTable();
        $columns = Schema::getColumnListing($table);

        return array_diff($columns, $this->excludedColumns);
    }

    /**
     * Get allowed columns based on fillable/guarded
     */
    protected function getAllowedColumns(): array
    {
        if (! $this->modelInstance) {
            return [];
        }

        $fillable = $this->modelInstance->getFillable();
        $guarded = $this->modelInstance->getGuarded();

        // If fillable is defined, use only fillable columns + timestamps + id
        if (! empty($fillable)) {
            return array_merge($fillable, ['id', 'created_at', 'updated_at']);
        }

        // If guarded is defined, exclude guarded columns
        if (! empty($guarded)) {
            $allColumns = $this->getTableColumns();
            return array_diff($allColumns, $guarded);
        }

        // If neither fillable nor guarded, return all columns
        return $this->getTableColumns();
    }

    /**
     * Check if column should be included
     */
    protected function shouldIncludeColumn(string $column, array $allowedColumns): bool
    {
        // Always include id, created_at, updated_at
        if (in_array($column, ['id', 'created_at', 'updated_at'])) {
            return true;
        }

        // Check if column is in allowed columns.
        if (! in_array($column, $allowedColumns)) {
            return false;
        }

        // Skip excluded columns.
        if (in_array($column, $this->excludedColumns)) {
            return false;
        }

        return true;
    }

    protected function isColumnSearchable(string $column): bool
    {
        // Text-based columns are typically searchable.
        $searchableTypes = ['string', 'text', 'varchar', 'char'];
        $columnType = $this->getColumnType($column);

        if (in_array($columnType, $searchableTypes)) {
            return true;
        }

        // ID columns can be searchable.
        if ($column === 'id') {
            return true;
        }

        return false;
    }

    protected function isColumnSortable(string $column): bool
    {
        // Most columns are sortable except json and large text fields
        $unsortableTypes = ['json', 'longtext', 'mediumtext'];
        $columnType = $this->getColumnType($column);

        return ! in_array($columnType, $unsortableTypes);
    }

    protected function getColumnType(string $column): string
    {
        if (! $this->modelInstance) {
            return 'string';
        }

        try {
            $table = $this->modelInstance->getTable();
            $columnInfo = DB::select("SHOW COLUMNS FROM {$table} WHERE Field = ?", [$column]);

            if (! empty($columnInfo)) {
                return strtolower($columnInfo[0]->Type);
            }
        } catch (\Exception $e) {
            // Fallback for different database types or connection issues
        }

        return 'string';
    }

    /**
     * Check if column needs custom renderer
     */
    protected function needsCustomRenderer(string $column): bool
    {
        // Timestamp columns need custom rendering.
        if (in_array($column, ['created_at', 'updated_at'])) {
            return true;
        }

        // Status, type columns often need custom rendering.
        if (Str::contains($column, ['status', 'type', '_at'])) {
            return true;
        }

        // Boolean columns.
        $columnType = $this->getColumnType($column);
        if (Str::contains($columnType, 'tinyint')) {
            return true;
        }

        return false;
    }

    /**
     * Get column renderer method name
     */
    protected function getColumnRenderer(string $column): string
    {
        if (in_array($column, ['created_at', 'updated_at'])) {
            return "render{$this->studlyCase($column)}Column";
        }

        if (Str::endsWith($column, '_at')) {
            return 'renderTimestampColumn';
        }

        return "render{$this->studlyCase($column)}Column";
    }

    protected function formatColumnTitle(string $column): string
    {
        return Str::title(str_replace('_', ' ', $column));
    }

    protected function studlyCase(string $value): string
    {
        return Str::studly($value);
    }

    protected function modelHasRelationship(string $relationship): bool
    {
        if (! $this->modelInstance) {
            return false;
        }

        try {
            $reflection = new ReflectionClass($this->modelInstance);
            $method = $reflection->getMethod($relationship);

            // Check if the method exists and is public.
            return $method->isPublic() && ! $method->isStatic();
        } catch (\ReflectionException $e) {
            return false;
        }
    }

    protected function getRelationshipSortColumn(string $relationship): string
    {
        // Most relationships can be sorted by their display column.
        return $relationship . '.name';
    }

    protected function buildQueryWithAutoSearch(): QueryBuilder
    {
        $query = $this->buildQuery();

        // Auto-apply search to generated searchable columns
        if ($this->search && ! empty($this->searchableColumns)) {
            $query->where(function ($q) {
                foreach ($this->searchableColumns as $column) {
                    $q->orWhere($column, 'like', '%' . $this->search . '%');
                }
            });
        }

        // Auto-include relationships if specified
        if (! empty($this->relationships)) {
            $query->with($this->relationships);
        }

        return $query;
    }

    public function renderTimestampColumn($item): string
    {
        $column = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 2)[1]['function'];
        $column = Str::snake(str_replace(['render', 'Column'], '', $column));

        if (! isset($item->$column) || ! $item->$column) {
            return '';
        }

        $short = $item->$column->format('d M Y');
        $full = $item->$column->format('Y-m-d H:i:s');

        return '<span class="text-sm" title="' . e($full) . '">' . e($short) . '</span>';
    }

    protected function getSearchbarPlaceholder(): string
    {
        if (! empty($this->searchableColumns)) {
            $columns = array_map(fn ($col) => $this->formatColumnTitle($col), $this->searchableColumns);
            $columnsList = implode(', ', array_slice($columns, 0, 3));
            return __('Search by :columns...', ['columns' => $columnsList]);
        }

        return __('Search...');
    }

    protected function getPermissions(): array
    {
        return [
            'create' => true,
            'view' => true,
            'edit' => true,
            'delete' => true,
        ];
    }

    protected function getActionsColumnHeader(): array
    {
        return [
            'id' => 'actions',
            'title' => __('Actions'),
            'sortBy' => '',
            'width' => null,
            'searchable' => false,
            'sortable' => false,
            'is_action' => true,
        ];
    }
}
